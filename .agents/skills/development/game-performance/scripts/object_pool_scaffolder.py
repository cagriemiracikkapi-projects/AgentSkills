#!/usr/bin/env python3
"""Generate a Unity C# ObjectPool implementation for a given type."""
import argparse
import re
from pathlib import Path


def to_pascal(name: str) -> str:
    return "".join(w.capitalize() for w in re.split(r"[-_\s]+", name))


def derive_interface_name(type_name: str) -> str:
    """Derive interface name: Bullet â†’ IBulletBehaviour, Enemy â†’ IEnemyBehaviour."""
    base = type_name.lstrip("I")
    return f"I{base}Behaviour"


def generate_pool(
    type_name: str,
    pool_name: str,
    initial_size: int,
    max_size: int,
    out_path: Path,
) -> str:
    interface_name = derive_interface_name(type_name)

    code = f"""\
// Auto-generated by object_pool_scaffolder.py
using System;
using UnityEngine;
using UnityEngine.Pool;

/// <summary>
/// ObjectPool for <see cref="{type_name}"/>.
/// Initial size: {initial_size}, Max size: {max_size}.
/// </summary>
public class {pool_name} : MonoBehaviour, IDisposable
{{
    [SerializeField] private {type_name} prefab;
    [SerializeField] private int initialSize = {initial_size};
    [SerializeField] private int maxSize = {max_size};

    private ObjectPool<{type_name}> _pool;
    private bool _disposed;

    private void Awake()
    {{
        _pool = new ObjectPool<{type_name}>(
            createFunc:    CreatePooledItem,
            actionOnGet:   OnGetFromPool,
            actionOnRelease: OnReturnedToPool,
            actionOnDestroy: OnDestroyPoolObject,
            collectionCheck: true,
            defaultCapacity: initialSize,
            maxSize:         maxSize
        );

        // Pre-warm pool to avoid GC spikes on first spawn burst
        var warmup = new {type_name}[initialSize];
        for (int i = 0; i < initialSize; i++) warmup[i] = _pool.Get();
        foreach (var item in warmup) _pool.Release(item);
    }}

    // --- Pool API ---

    public {type_name} Get() => _pool.Get();

    public void Release({type_name} obj) => _pool.Release(obj);

    // --- Callbacks ---

    private {type_name} CreatePooledItem()
    {{
        var obj = Instantiate(prefab);
        // Inject pool reference so the object can release itself
        if (obj is {interface_name} behaviour)
            behaviour.SetPool(this);
        return obj;
    }}

    private void OnGetFromPool({type_name} obj)
    {{
        obj.gameObject.SetActive(true);
    }}

    private void OnReturnedToPool({type_name} obj)
    {{
        obj.gameObject.SetActive(false);
    }}

    private void OnDestroyPoolObject({type_name} obj)
    {{
        Destroy(obj.gameObject);
    }}

    // --- IDisposable ---

    public void Dispose()
    {{
        if (_disposed) return;
        _disposed = true;
        _pool?.Dispose();
    }}

    private void OnDestroy() => Dispose();
}}

/// <summary>
/// Implement this interface on <see cref="{type_name}"/> to receive pool injection.
/// </summary>
public interface {interface_name}
{{
    void SetPool({pool_name} pool);
}}
"""
    return code


def main():
    parser = argparse.ArgumentParser(description="Generate a Unity C# ObjectPool for a given component type.")
    parser.add_argument("pool_name", help="Pool class name (e.g. BulletPool)")
    parser.add_argument("--type", required=True, dest="type_name",
                        help="Pooled MonoBehaviour type (e.g. Bullet)")
    parser.add_argument("--initial-size", type=int, default=20,
                        help="Pre-warm pool size (default: 20)")
    parser.add_argument("--max-size", type=int, default=200,
                        help="Maximum pool capacity (default: 200)")
    parser.add_argument("--out", default="Assets/Scripts/Pooling",
                        help="Output directory (default: Assets/Scripts/Pooling)")
    args = parser.parse_args()

    pool_name = to_pascal(args.pool_name)
    type_name = to_pascal(args.type_name)
    out_dir = Path(args.out)
    out_dir.mkdir(parents=True, exist_ok=True)

    out_path = out_dir / f"{pool_name}.cs"
    code = generate_pool(type_name, pool_name, args.initial_size, args.max_size, out_path)
    out_path.write_text(code, encoding="utf-8")

    print("ðŸ“¦ Object Pool Scaffolder")
    print(f"Type:         {type_name}")
    print(f"Pool class:   {pool_name}")
    print(f"Interface:    {derive_interface_name(type_name)}")
    print(f"Initial size: {args.initial_size}")
    print(f"Max size:     {args.max_size}")
    print(f"Output:       {out_path}")
    print()
    print("âœ… Pool generated. Steps to integrate:")
    print(f"  1. Add {pool_name} as a MonoBehaviour on a GameObject in your scene.")
    print(f"  2. Assign the {type_name} prefab in the Inspector.")
    print(f"  3. Implement {derive_interface_name(type_name)} on {type_name} to call pool.Release(this) when done.")
    print("  4. Inject the pool into your spawner (e.g. EnemySpawner) via [SerializeField].")


if __name__ == "__main__":
    main()
