#!/usr/bin/env node
'use strict';

const fs = require('fs');
const path = require('path');

const args = process.argv.slice(2);

// --- Color parsing ---

function parseHex(hex) {
    const clean = hex.replace('#', '');
    const r = parseInt(clean.substring(0, 2), 16);
    const g = parseInt(clean.substring(2, 4), 16);
    const b = parseInt(clean.substring(4, 6), 16);
    return { r, g, b };
}

function rgbToHsl(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s;
    const l = (max + min) / 2;
    if (max === min) {
        h = s = 0;
    } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
            case g: h = ((b - r) / d + 2) / 6; break;
            case b: h = ((r - g) / d + 4) / 6; break;
        }
    }
    return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
}

function hslToHex(h, s, l) {
    s /= 100; l /= 100;
    const a = s * Math.min(l, 1 - l);
    const f = n => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * color).toString(16).padStart(2, '0');
    };
    return `#${f(0)}${f(8)}${f(4)}`;
}

function parseColor(input) {
    if (!input) return null;
    const str = input.trim();

    // Hex
    if (str.startsWith('#')) {
        const { r, g, b } = parseHex(str);
        return rgbToHsl(r, g, b);
    }

    // hsl(h, s%, l%)
    const hslM = str.match(/hsl\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*\)/i);
    if (hslM) return { h: +hslM[1], s: +hslM[2], l: +hslM[3] };

    // rgb(r, g, b)
    const rgbM = str.match(/rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i);
    if (rgbM) return rgbToHsl(+rgbM[1], +rgbM[2], +rgbM[3]);

    // Named colors (basic set)
    const named = {
        white: '#ffffff', black: '#000000', red: '#ef4444', blue: '#3b82f6',
        green: '#22c55e', yellow: '#eab308', purple: '#a855f7', orange: '#f97316',
        pink: '#ec4899', gray: '#6b7280', grey: '#6b7280',
    };
    if (named[str.toLowerCase()]) {
        const { r, g, b } = parseHex(named[str.toLowerCase()]);
        return rgbToHsl(r, g, b);
    }

    return null;
}

// --- Scale generation ---
// Tailwind-like: 50, 100, 200, ..., 900, 950
// Lightness spread: 50â†’97%, 100â†’94%, ..., 900â†’10%, 950â†’5%
const SCALE_STEPS = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950];
const LIGHTNESS_MAP = {
    50: 97, 100: 94, 200: 86, 300: 74, 400: 62, 500: 50,
    600: 40, 700: 30, 800: 20, 900: 10, 950: 5,
};

function generateScale(colorName, hsl) {
    const { h, s } = hsl;
    const scale = {};
    for (const step of SCALE_STEPS) {
        const l = LIGHTNESS_MAP[step];
        scale[step] = hslToHex(h, s, l);
    }
    return scale;
}

// --- oklch note ---
function oklchNote(colorName, hsl) {
    // oklch(L C H) â€” approximate from HSL
    // L: 0â†’1, C: chroma ~0.2 for vivid, H: same hue
    const L = (hsl.l / 100).toFixed(2);
    const C = (hsl.s / 500).toFixed(3); // rough approximation
    return `oklch(${L} ${C} ${hsl.h})`;
}

// --- File generation ---

function generateTailwindConfig(colorName, scale) {
    const entries = SCALE_STEPS.map(s => `        '${s}': '${scale[s]}',`).join('\n');
    return `/** @type {import('tailwindcss').Config} */
module.exports = {
  theme: {
    extend: {
      colors: {
        '${colorName}': {
${entries}
        },
      },
    },
  },
  plugins: [],
};
`;
}

function generateCSSVars(colorName, scale) {
    const vars = SCALE_STEPS.map(s => `  --color-${colorName}-${s}: ${scale[s]};`).join('\n');
    return `/* Design tokens: ${colorName} color scale */
/* Generated by token_generator.js */
:root {
${vars}
}

/* oklch gamut-aware alternative (modern CSS P3 support) */
@supports (color: oklch(0 0 0)) {
  :root {
    /* Replace with accurate oklch values from your design tool */
  }
}
`;
}

function generateTokensJson(colorName, scale, hsl) {
    const tokens = {};
    for (const step of SCALE_STEPS) {
        tokens[`${colorName}-${step}`] = {
            value: scale[step],
            type: 'color',
            attributes: { category: 'color', type: colorName, item: String(step) },
        };
    }
    return JSON.stringify({
        color: { [colorName]: tokens },
        _meta: {
            generated: new Date().toISOString(),
            baseHSL: hsl,
            oklchApprox: oklchNote(colorName, hsl),
        }
    }, null, 2);
}

function main() {
    const colorIdx = args.indexOf('--color');
    const nameIdx = args.indexOf('--name');
    const outIdx = args.indexOf('--out');

    const colorInput = colorIdx !== -1 && args[colorIdx + 1] ? args[colorIdx + 1] : null;
    const colorName = nameIdx !== -1 && args[nameIdx + 1] ? args[nameIdx + 1] : 'brand';
    const outDir = outIdx !== -1 && args[outIdx + 1]
        ? path.resolve(process.cwd(), args[outIdx + 1])
        : path.resolve(process.cwd(), 'tokens');

    console.log('ðŸŽ¨ Design Token Generator');

    if (!colorInput) {
        console.log('\nUsage:');
        console.log('  node token_generator.js --color <hex|hsl|rgb|name> [--name brand] [--out tokens/]');
        console.log('\nExamples:');
        console.log('  node token_generator.js --color "#3b82f6" --name primary');
        console.log('  node token_generator.js --color "hsl(217, 91%, 60%)" --name blue');
        console.log('  node token_generator.js --color "rgb(59, 130, 246)" --name accent');
        process.exit(1);
    }

    const hsl = parseColor(colorInput);
    if (!hsl) {
        console.error(`Could not parse color: ${colorInput}`);
        console.error('Supported formats: #hex, hsl(h, s%, l%), rgb(r, g, b), named colors');
        process.exit(1);
    }

    console.log(`Color input: ${colorInput}`);
    console.log(`Parsed HSL:  hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`);
    console.log(`oklch approx: ${oklchNote(colorName, hsl)}`);
    console.log(`Name:        ${colorName}`);
    console.log(`Steps:       ${SCALE_STEPS.join(', ')}\n`);

    const scale = generateScale(colorName, hsl);

    // Print scale
    console.log('Generated scale:');
    for (const step of SCALE_STEPS) {
        console.log(`  ${String(step).padStart(4)}: ${scale[step]}`);
    }
    console.log();

    // Write files
    fs.mkdirSync(outDir, { recursive: true });

    const tailwindPath = path.join(process.cwd(), 'tailwind.config.js');
    fs.writeFileSync(tailwindPath, generateTailwindConfig(colorName, scale), 'utf8');
    console.log(`âœ… ${tailwindPath}`);

    const cssPath = path.join(outDir, 'variables.css');
    fs.writeFileSync(cssPath, generateCSSVars(colorName, scale), 'utf8');
    console.log(`âœ… ${cssPath}`);

    const tokensPath = path.join(outDir, 'tokens.json');
    fs.writeFileSync(tokensPath, generateTokensJson(colorName, scale, hsl), 'utf8');
    console.log(`âœ… ${tokensPath}`);

    console.log('\nâœ… Token generation complete.');
    console.log('Next: Verify oklch values in your design tool for P3 wide-gamut accuracy.');
}

main();
